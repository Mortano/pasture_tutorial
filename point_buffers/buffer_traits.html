<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The buffer traits - pasture</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../using_pasture.html"><strong aria-hidden="true">2.</strong> Using pasture</a></li><li class="chapter-item expanded "><a href="../data_model.html"><strong aria-hidden="true">3.</strong> pasture data model</a></li><li class="chapter-item expanded "><a href="../point_layout.html"><strong aria-hidden="true">4.</strong> Point layout in detail</a></li><li class="chapter-item expanded "><a href="../point_buffers.html"><strong aria-hidden="true">5.</strong> Point buffers in detail</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../point_buffers/builtin_types.html"><strong aria-hidden="true">5.1.</strong> The built-in point buffer types</a></li><li class="chapter-item expanded "><a href="../point_buffers/buffer_traits.html" class="active"><strong aria-hidden="true">5.2.</strong> The buffer traits</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Implementing your own point buffer type</div></li><li class="chapter-item expanded "><a href="../point_buffers/buffer_slices.html"><strong aria-hidden="true">5.4.</strong> Buffer slices</a></li></ol></li><li class="chapter-item expanded "><a href="../examples.html"><strong aria-hidden="true">6.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/basic_usage.html"><strong aria-hidden="true">6.1.</strong> Basic usage</a></li><li class="chapter-item expanded "><a href="../examples/point_io.html"><strong aria-hidden="true">6.2.</strong> Reading and writing general point cloud files</a></li><li class="chapter-item expanded "><a href="../examples/reading_las.html"><strong aria-hidden="true">6.3.</strong> Reading LAS files</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">pasture</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-buffer-traits-that-pasture-exposes"><a class="header" href="#the-buffer-traits-that-pasture-exposes">The buffer traits that <code>pasture</code> exposes</a></h1>
<p>While <code>pasture</code> has only three primary built-in buffer types at the moment, it exposes a hierarchy of buffer traits that define the memory layout and ownership model that <code>pasture</code> is built around. In this section you will learn about all the different buffer traits and gain a deeper understanding of how <code>pasture</code> treats point cloud memory.</p>
<h2 id="memory-layout-vs-ownership"><a class="header" href="#memory-layout-vs-ownership">Memory layout vs. ownership</a></h2>
<p>At its core, <code>pasture</code> distinguishes between two properties of a point buffer: Its <strong>memory layout</strong> and its <strong>memory ownership model</strong>. Each of these two properties comes in several 'flavors' which can (for the most part) be freely combined, resulting in a large number of potential buffer types. The following image shows the full buffer trait hierarchy in <code>pasture</code>:</p>
<p><img src="../figures/buffer_trait_hierarchy.svg" alt="Image showing the buffer trait hierarchy in pasture" /></p>
<p>For the memory ownership, <code>pasture</code> distinguishes between three types of ownership:</p>
<ul>
<li>A buffer immutably borrows its memory. This is the weakest guarantee and represented by the base trait <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html"><code>BorrowedBuffer&lt;'a&gt;</code></a></li>
<li>A buffer mutably borrows its memory. This is the next stronger guarantee and represented by the <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedMutBuffer.html"><code>BorrowedMutBuffer&lt;'a&gt;</code></a> trait</li>
<li>A buffer owns its memory. This is the strongest guarantee and represented by the <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.OwningBuffer.html"><code>OwningBuffer&lt;'a&gt;</code></a> trait</li>
</ul>
<p>Each stronger ownership guarantee implies all weaker guarantees, which is why <code>OwningBuffer&lt;'a&gt;</code> is a supertrait of <code>BorrowedMutBuffer&lt;'a&gt;</code>, which in turn is a supertrait of <code>BorrowedBuffer&lt;'a&gt;</code>. This also explains why <code>OwningBuffer&lt;'a&gt;</code> has a lifetime bound: <code>BorrowedBuffer&lt;'a&gt;</code> requires a lifetime bound to tell the borrow checker for which lifetime <code>'a</code> the memory is borrowed, and this propagates to all supertraits.</p>
<p>For the memory layout, there are three options:</p>
<ul>
<li>An unspecified memory layout, which only allows accessing points and attributes by value (through copy operations). This is the memory layout guarantee that <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html"><code>BorrowedBuffer&lt;'a&gt;</code></a> has</li>
<li>An <em>interleaved</em> memory layout, which allows accessing point data by reference/borrow. Mutable access requires a mutable ownership model, which is why <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.InterleavedBuffer.html"><code>InterleavedBuffer&lt;'a&gt;</code></a> is only a supertrait of <code>BorrowedBuffer&lt;'a&gt;</code> and provides only immutable point access, whereas <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.InterleavedBufferMut.html"><code>InterleavedBufferMut&lt;'a&gt;</code></a> is a supertrait of <code>BorrowedMutBuffer&lt;'a&gt;</code> and allows mutably borrowing points.</li>
<li>A <em>columnar</em> memory layout, which allows accessing attribute data by reference/borrow. Analogous to the interleaved layout traits, <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.ColumnarBuffer.html"><code>ColumnarBuffer&lt;'a&gt;</code></a> only allows immutable borrows and thus is a supertrait of <code>BorrowedBuffer&lt;'a&gt;</code>, whereas <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.ColumnarBufferMut.html"><code>ColumnarBufferMut&lt;'a&gt;</code></a> is a supertrait of <code>BorrowedMutBuffer&lt;'a&gt;</code> and allows mutably borrowing attribute values.</li>
</ul>
<p>Here are some examples of existing buffer types and which traits they implement:</p>
<ul>
<li><code>VectorBuffer</code> owns its memory (since it uses a <code>Vec&lt;u8&gt;</code>) and stores data in interleaved layout, so it implements:
<ul>
<li><code>OwningBuffer&lt;'a&gt;</code> (and thus also <code>BorrowedMutBuffer&lt;'a&gt;</code> and <code>BorrowedBuffer&lt;'a&gt;</code>)</li>
<li><code>InterleavedBuffer&lt;'a&gt;</code> and <code>InterleavedBufferMut&lt;'a&gt;</code></li>
</ul>
</li>
<li><code>HashMapBuffer</code> owns its memory (using a <code>HashMap</code> with <code>Vec&lt;u8&gt;</code> values) and stores data in a columnar layout, so it implements:
<ul>
<li><code>OwningBuffer&lt;'a&gt;</code> (and thus also <code>BorrowedMutBuffer&lt;'a&gt;</code> and <code>BorrowedBuffer&lt;'a&gt;</code>)</li>
<li><code>ColumnarBuffer&lt;'a&gt;</code> and <code>ColumnarBufferMut&lt;'a&gt;</code></li>
</ul>
</li>
<li><code>ExternalMemoryBuffer&lt;T&gt;</code> does <em>not</em> own its memory (the whole point of this buffer type!) and stores data in interleaved layout, so it implements:
<ul>
<li><code>BorrowedBuffer&lt;'a&gt;</code></li>
<li><code>BorrowedMutBuffer&lt;'a&gt;</code> only if the memory region type <code>T</code> is mutably borrowed</li>
<li><code>InterleavedBuffer&lt;'a&gt;</code> and—if the memory region type <code>T</code> is mutably borrowed—<code>InterleavedBufferMut&lt;'a&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="the-root-trait-borrowedbuffera"><a class="header" href="#the-root-trait-borrowedbuffera">The root trait <code>BorrowedBuffer&lt;'a&gt;</code></a></h2>
<p>All point buffers in <code>pasture</code> implement the root trait <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html"><code>BorrowedBuffer&lt;'a&gt;</code></a>, so it makes sense to take a closer look at it. Here is the trait definition (without provided methods):</p>
<pre><pre class="playground"><code class="language-rust editable">pub trait BorrowedBuffer&lt;'a&gt; {
    // Required methods
    fn len(&amp;self) -&gt; usize;
    fn point_layout(&amp;self) -&gt; &amp;PointLayout;
    fn get_point(&amp;self, index: usize, data: &amp;mut [u8]);
    fn get_point_range(&amp;self, range: Range&lt;usize&gt;, data: &amp;mut [u8]);
    unsafe fn get_attribute_unchecked(
        &amp;self,
        attribute_member: &amp;PointAttributeMember,
        index: usize,
        data: &amp;mut [u8]
    );
}</code></pre></pre>
<p>The first two methods it defines are not strictly related to memory ownership or layout and instead are fundamental properties of all point buffers: Each buffer as a <code>PointLayout</code> and stores some number of points. These can be accessed through <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html#tymethod.point_layout"><code>fn point_layout(&amp;self) -&gt; &amp;PointLayout</code></a> and <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html#tymethod.len"><code>fn len(&amp;self) -&gt; usize</code></a> respectively.</p>
<p>The next three methods are the most fundamental accessor methods for point and attribute data in a point buffer. As a user, you will rarely interact with these methods directly as they work exclusively with untyped memory (in the form of byte slices <code>[u8]</code>). Let's first look at accessing point data:</p>
<pre><pre class="playground"><code class="language-rust editable">fn get_point(&amp;self, index: usize, data: &amp;mut [u8]);
fn get_point_range(&amp;self, range: Range&lt;usize&gt;, data: &amp;mut [u8]);</code></pre></pre>
<p>These functions copy the data for a single point (<code>get_point</code>) or a range of consecutive points (<code>get_point_range</code>) into a user-defined byte buffer. Since we are still in untyped land, the signature is <code>fn get_point(&amp;self, index: usize, data: &amp;mut [u8])</code> and not <code>fn get_point&lt;T: PointType&gt;(&amp;self, index: usize) -&gt; T</code>.</p>
<div id="admonition-hint" class="admonition admonish-tip">
<div class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="#admonition-hint"></a></p>
</div>
<div>
<p>The signature <code>fn get_point&lt;T: PointType&gt;(&amp;self, index: usize) -&gt; T</code> would make the <code>BorrowedBuffer&lt;'a&gt;</code> trait object-unsafe, so we could never create trait objects from it. This would be an unnecessary limitation. Instead, this is what the views do: <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/struct.PointView.html#method.at"><code>PointView::at</code></a> has exactly this signature, except that the type <code>T</code> is part of the <code>PointView</code> type.</p>
</div>
</div>
<p>Working with untyped memory might seem terribly unsafe, but <code>pasture</code> hides a lot of the unsafety. The only requirement for calling <code>get_point</code> or <code>get_point_range</code> is that the memory buffer passed into these functions has to be large enough to store the requested point data. In that regard it is similar to calling <a href="https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read"><code>Read::read</code></a>, a common function in Rust.</p>
<p>A more complex function is the accessor for attribute data:</p>
<pre><pre class="playground"><code class="language-rust editable">unsafe fn get_attribute_unchecked(
    &amp;self,
    attribute_member: &amp;PointAttributeMember,
    index: usize,
    data: &amp;mut [u8]
);</code></pre></pre>
<p>This is an <code>unsafe</code> function because it is an optimized accessor that bypasses checks (hence the <code>unchecked</code> suffix, a common pattern in Rust). It is the faster but more unsafe variant of <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html#method.get_attribute"><code>get_attribute</code></a>. It copies the data for a specific point attribute of the point at <code>index</code> into the user-provided buffer. Accessing this data might require knowledge of the offset of the point attribute within the <code>PointLayout</code>, which is why <code>get_attribute_unchecked</code> requires a <code>PointAttributeMember</code> instead of the more general <code>PointAttributeDefinition</code>.</p>
<p>A neat thing is that both <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html#method.get_attribute"><code>get_attribute</code></a> and <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html#method.get_attribute_range"><code>get_attribute_range</code></a> (for getting attribute values for multiple consecutive points) can be implemented using <code>get_attribute</code>, so implementors of <code>BorrowedBuffer&lt;'a&gt;</code> only need to provide one method instead of two.</p>
<div id="admonition-hint-1" class="admonition admonish-tip">
<div class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="#admonition-hint-1"></a></p>
</div>
<div>
<p>Notice that every buffer access method of <code>BorrowedBuffer&lt;'a&gt;</code> requires copying the point/attribute data! This is precisely what it means to have an unspecified memory layout: No guarantee can be made that it is possible to access points or attributes through references, so we have to resort to copying! Examples of buffer types that cannot make guarantees about their memory layout would be buffers sorting data in disjoint memory regions (e.g. using a linked list) or buffers generating data on the fly.</p>
</div>
</div>
<p>Based on these three accessor functions, a bunch of provided functions are implemented:</p>
<pre><pre class="playground"><code class="language-rust editable">fn get_attribute(
    &amp;self,
    attribute: &amp;PointAttributeDefinition,
    index: usize,
    data: &amp;mut [u8]
) { ... }
fn get_attribute_range(
    &amp;self,
    attribute: &amp;PointAttributeDefinition,
    point_range: Range&lt;usize&gt;,
    data: &amp;mut [u8]
) { ... }
fn view&lt;'b, T: PointType&gt;(&amp;'b self) -&gt; PointView&lt;'a, 'b, Self, T&gt;
    where Self: Sized,
            'a: 'b { ... }
fn view_attribute&lt;'b, T: PrimitiveType&gt;(
    &amp;'b self,
    attribute: &amp;PointAttributeDefinition
) -&gt; AttributeView&lt;'a, 'b, Self, T&gt;
    where Self: Sized,
            'a: 'b { ... }
fn view_attribute_with_conversion&lt;'b, T: PrimitiveType&gt;(
    &amp;'b self,
    attribute: &amp;PointAttributeDefinition
) -&gt; Result&lt;AttributeViewConverting&lt;'a, 'b, Self, T&gt;&gt;
    where Self: Sized,
            'a: 'b { ... }</code></pre></pre>
<p>We already saw <code>get_attribute</code> and <code>get_attribute_range</code>, and in previous examples also <code>view</code> and <code>view_attribute</code>. The latter return the <code>PointView</code> and <code>AttributeView</code> types, which internally use the raw data accessor functions to convert untyped memory into typed values. There is one special view type that we haven't talked about: <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/struct.AttributeViewConverting.html"><code>AttributeViewConverting</code></a>.</p>
<h2 id="converting-attributes"><a class="header" href="#converting-attributes">Converting attributes</a></h2>
<p>The <code>view_attribute</code> function is very strict: It requires that the <code>PointAttributeDefinition</code> passed in <em>exactly matches</em> the definition in the <code>PointLayout</code> of the buffer. This means that both the name <em>and</em> the datatype must match! <code>pasture</code> checks this at runtime and panics if this invariant is not met! Here is an example why this can be problematic:</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(PointType, Clone, Copy, bytemuck::NoUninit, bytemuck::AnyBitPattern)]
#[repr(C, packed)]
struct CustomPointType {
    #[pasture(BUILTIN_INTENSITY)]
    pub intensity: u16,
    #[pasture(BUILTIN_POSITION_3D)]
    pub position: Vector3&lt;f32&gt;,
    #[pasture(attribute = "CUSTOM_ATTRIBUTE")]
    pub custom_attribute: f32,
}</code></pre></pre>
<p>The <code>CustomPointType</code> type (from the <a href="../point_layout.html">point layout section</a>) stores a <code>POSITION_3D</code> attribute, but with a different datatype than the default one (<code>Vector3&lt;f32&gt;</code> instead of <code>Vector3&lt;f64&gt;</code>). Calling <code>view_attribute::&lt;Vector3&lt;f64&gt;&gt;(&amp;POSITION_3D)</code> on a buffer with the <code>CustomPointType</code> layout will panic! Calling <code>view_attribute::&lt;Vector3&lt;f32&gt;&gt;(&amp;POSITION_3D)</code> (<code>f32</code> instead of <code>f64</code>) will panic as well!</p>
<div id="admonition-warning" class="admonition admonish-warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="#admonition-warning"></a></p>
</div>
<div>
<p>This may seem annoying, but is due to safety reasons! The resulting view type performs raw memory transmutations, which are amongst the most unsafe things that you can do in Rust. So <code>pasture</code> has to make absolutely sure that these transmutations are valid, which they only are if we view the untyped memory in the exact types specified in the buffer's <code>PointLayout</code>!</p>
</div>
</div>
<p>There is a way to deal with this problem: We could convert from <code>Vector3&lt;f64&gt;</code> to <code>Vector3&lt;f32&gt;</code>, accepting a loss of precision. In fact, there are a bunch of possible conversions, essentially everything that the <a href="https://doc.rust-lang.org/std/keyword.as.html"><code>as</code> operator</a> allows, which we can lift to the <code>nalgebra</code> vector types. If we want such a conversion, <code>pasture</code> still has to do an initial memory transmutation to the actual type of the attribute, but then it can apply an <code>as</code> transformation. This is precisely what <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html#method.view_attribute_with_conversion"><code>view_attribute_with_conversion</code></a> does: It returns a view over attribute values in the strong type <code>T: PrimitiveType</code>, even if <code>T</code> is different from the datatype of the attribute within the buffer. Not all conversions are valid, for example vector-to-scalar conversions, which is why this function returns a <code>Result</code>. Since the resulting attribute view performs conversions, it only ever supports accessing attribute data by value.</p>
<h2 id="mutable-access-to-buffer-data-using-borrowedmutbuffera"><a class="header" href="#mutable-access-to-buffer-data-using-borrowedmutbuffera">Mutable access to buffer data using <code>BorrowedMutBuffer&lt;'a&gt;</code></a></h2>
<p>Let's look at the <code>BorrowedMutBuffer&lt;'a&gt;</code> type and the additional methods it provides. First, here are the required methods:</p>
<pre><pre class="playground"><code class="language-rust editable">pub trait BorrowedMutBuffer&lt;'a&gt;: BorrowedBuffer&lt;'a&gt; {
    // Required methods
    unsafe fn set_point(&amp;mut self, index: usize, point_data: &amp;[u8]);
    unsafe fn set_point_range(
        &amp;mut self,
        point_range: Range&lt;usize&gt;,
        point_data: &amp;[u8]
    );
    unsafe fn set_attribute(
        &amp;mut self,
        attribute: &amp;PointAttributeDefinition,
        index: usize,
        attribute_data: &amp;[u8]
    );
    unsafe fn set_attribute_range(
        &amp;mut self,
        attribute: &amp;PointAttributeDefinition,
        point_range: Range&lt;usize&gt;,
        attribute_data: &amp;[u8]
    );
    fn swap(&amp;mut self, from_index: usize, to_index: usize);
}</code></pre></pre>
<p>Where previously we had a bunch of get-accessors, here we see set-methods for points and attributes as well as ranges thereof. There is also <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedMutBuffer.html#tymethod.swap"><code>swap</code></a> for swapping the point data at to indices (very helpful for implementing sorting).</p>
<div id="admonition-accessing-ranges-of-points" class="admonition admonish-tip">
<div class="admonition-title">
<p>Accessing ranges of points</p>
<p><a class="admonition-anchor-link" href="#admonition-accessing-ranges-of-points"></a></p>
</div>
<div>
<p>The <code>get</code> and <code>set</code> functions on the basic buffer traits come in two flavors: Accessing individual pieces of data (e.g. <code>set_point</code>, <code>set_attribute</code>) and accessing ranges of data (e.g. <code>set_point_range</code>, <code>set_attribute_range</code>). If you have to access consecutive points or attributes, prefer to use the range accessors instead of multiple calls to the individual accessors!</p>
</div>
</div>
<p>Notice that all four set-methods are <code>unsafe</code>! They have to be, because <code>pasture</code> has no way of checking whether the data passed into these functions actually corresponds to the memory layout of the buffer! For this reason, you have to be <em>very</em> careful when calling these functions directly. Again, a lot of the unsafety is hidden by using point and attribute views.</p>
<p>Similar to <code>BorrowedBuffer&lt;'a&gt;</code>, a bunch of helper functions are provided:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transform_attribute&lt;'b, T: PrimitiveType, F: Fn(usize, T) -&gt; T&gt;(
    &amp;'b mut self,
    attribute: &amp;PointAttributeDefinition,
    func: F
)
    where Self: Sized,
            'a: 'b { ... }
fn view_mut&lt;'b, T: PointType&gt;(&amp;'b mut self) -&gt; PointViewMut&lt;'a, 'b, Self, T&gt;
    where Self: Sized,
            'a: 'b { ... }
fn view_attribute_mut&lt;'b, T: PrimitiveType&gt;(
    &amp;'b mut self,
    attribute: &amp;PointAttributeDefinition
) -&gt; AttributeViewMut&lt;'a, 'b, Self, T&gt;
    where Self: Sized,
            'a: 'b { ... }
<span class="boring">}</span></code></pre></pre>
<p>We have mutable view accessors (<a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedMutBuffer.html#method.view_mut"><code>view_mut</code></a> and <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedMutBuffer.html#method.view_attribute_mut"><code>view_attribute_mut</code></a>) as well as one special function <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedMutBuffer.html#method.transform_attribute"><code>transform_attribute</code></a>. This special function allows in-place manipulation of all values of a specific attribute. It is a more efficient version of the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut buffer = ...;
let mut view = buffer.view_attribute_mut::&lt;u16&gt;(&amp;INTENSITY);
for index in 0..buffer.len() {
    let mut intensity = view.at(index);
    intensity *= 2; // Apply some transformation to the intensity value
    view.set_at(index, intensity);
}
<span class="boring">}</span></code></pre></pre>
<p>This <code>at</code>/<code>set_at</code> pattern is necessary because <code>BorrowedMutBuffer&lt;'a&gt;</code> does not know anything about the memory layout of its implementor, so it only provides data access by value. To mutate a value, we have to copy it out of the buffer (using <code>at</code>) and then write the mutated value back into the buffer (using <code>set_at</code>). The same can be achieved using <code>transform_attribute</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut buffer = ...;
buffer.transform_attribute(&amp;INTENSITY, |_index: usize, intensity: u16| -&gt; u16 {
    intensity * 2
});
<span class="boring">}</span></code></pre></pre>
<h2 id="resizing-buffers-using-the-owningbuffera-trait"><a class="header" href="#resizing-buffers-using-the-owningbuffera-trait">Resizing buffers using the <code>OwningBuffer&lt;'a&gt;</code> trait</a></h2>
<p>The last memory ownership trait is <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.OwningBuffer.html"><code>OwningBuffer&lt;'a&gt;</code></a>. A buffer that implements this trait is the owner of its memory, which means that we can resize this buffer. Let's look at the required methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait OwningBuffer&lt;'a&gt;: BorrowedMutBuffer&lt;'a&gt; + Sized {
    // Required methods
    unsafe fn push_points(&amp;mut self, point_bytes: &amp;[u8]);
    fn resize(&amp;mut self, count: usize);
    fn clear(&amp;mut self);
    fn append_interleaved&lt;'b, B: InterleavedBuffer&lt;'b&gt;&gt;(&amp;mut self, other: &amp;B);
    fn append_columnar&lt;'b, B: ColumnarBuffer&lt;'b&gt;&gt;(&amp;mut self, other: &amp;B);
}
<span class="boring">}</span></code></pre></pre>
<p>It provides three general resizing functions that are similar to those that <code>Vec</code> provides: <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.OwningBuffer.html#tymethod.push_points"><code>push_points</code></a>, <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.OwningBuffer.html#tymethod.resize"><code>resize</code></a>, and <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.OwningBuffer.html#tymethod.clear"><code>clear</code></a>.</p>
<p><code>push_points</code> is the resizing variant of <code>set_point_range</code> from the <code>BorrowedMutBuffer&lt;'a&gt;</code> trait: It appends the provided points to the end of the buffer. It is <code>unsafe</code> because it can't check whether the memory passed to it conforms to the <code>PointLayout</code> of the buffer.</p>
<p><code>resize</code> and <code>clear</code> follow the same logic as their identically-named counterparts in <code>Vec</code>: <code>resize</code> resizes the buffer so that it contains the given number of points, default-constructing new points as needed. This works since all point types in pasture are zero-initializable. <code>clear</code> clears the contents of the buffer so that its new length is 0.</p>
<p>There are two <code>append_...</code> functions, which take a buffer in a specified memory layout (interleaved or columnar) and appends the points from this buffer to the current buffer. The distinction regarding the memory layout can enable faster copy operations, as appending to a buffer with the same memory layout will be more efficient as appending to a buffer with a different memory layout. There is also a provided function <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.OwningBuffer.html#method.append"><code>append</code></a>, which does not make assumptions regarding the memory layout of the buffer that shall be appended. It is easier to use but generally will have worse performance.</p>
<h2 id="the-memory-layout-traits"><a class="header" href="#the-memory-layout-traits">The memory layout traits</a></h2>
<p>The memory ownership traits made no assumptions about the memory layout of a point buffer. <code>pasture</code> does however support two specific memory layouts natively: <em>Interleaved</em> and <em>columnar</em>. We already saw the two default buffer types corresponding to these layouts in the section on <a href="./builtin_types.html">built-in buffer types</a>: <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/struct.VectorBuffer.html"><code>VectorBuffer</code></a> is the default interleaved buffer, and <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/struct.HashMapBuffer.html"><code>HashMapBuffer</code></a> the default columnar buffer. Both memory layouts have their own traits, which we will look at in the remainder of this section. As a recap, here is a picture showing the difference between interleaved and columnar memory layout:</p>
<p><img src="../figures/aos_vs_soa_memory_layout.svg" alt="Picture showing the difference between interleaved (AoS) and columnar (SoA) memory layouts" /></p>
<h3 id="interleaved-buffers-and-the-interleavedbuffera-trait"><a class="header" href="#interleaved-buffers-and-the-interleavedbuffera-trait">Interleaved buffers and the <code>InterleavedBuffer&lt;'a&gt;</code> trait</a></h3>
<p>All interleaved buffers in <code>pasture</code> implement the <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.InterleavedBuffer.html"><code>InterleavedBuffer&lt;'a&gt;</code></a> trait. Here is how it looks like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait InterleavedBuffer&lt;'a&gt;: BorrowedBuffer&lt;'a&gt; {
    // Required methods
    fn get_point_ref&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b [u8]
       where 'a: 'b;
    fn get_point_range_ref&lt;'b&gt;(&amp;'b self, range: Range&lt;usize&gt;) -&gt; &amp;'b [u8]
       where 'a: 'b;
}
<span class="boring">}</span></code></pre></pre>
<p>It is a supertrait of the basic buffer trait <code>BorrowedBuffer&lt;'a&gt;</code> and adds two new accessor methods: <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.InterleavedBuffer.html#tymethod.get_point_ref"><code>get_point_ref</code></a> and <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.InterleavedBuffer.html#tymethod.get_point_range_ref"><code>get_point_range_ref</code></a>. They provide by-reference access to individual points and ranges of points, which is precisely what 'interleaved memory layout' means. These functions return raw byte slices (i.e. the raw memory of the points) but they are what enables the <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/struct.PointView.html#method.at_ref"><code>at_ref</code></a> and <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/struct.PointView.html#method.iter"><code>iter</code></a> functions of point views!</p>
<div id="admonition-borrowing-from-a-borrowed-buffer" class="admonition admonish-tip">
<div class="admonition-title">
<p>Borrowing from a borrowed buffer</p>
<p><a class="admonition-anchor-link" href="#admonition-borrowing-from-a-borrowed-buffer"></a></p>
</div>
<div>
<p><code>InterleavedBuffer&lt;'a&gt;</code> allows borrowing data from a buffer, which itself might borrow its memory. For this reason, <code>get_point_ref</code> and <code>get_point_range_ref</code> have more complex lifetime bounds: They borrow data for some lifetime <code>'b</code>, which is at most as long as lifetime <code>'a</code>. This is expressed through <code>where 'a: 'b</code>, which can be read as "<code>'a</code> must life at least as long as <code>'b</code>". This allows borrowing point data for short lifetimes than <code>'a</code>, which can sometimes be necessary.</p>
</div>
</div>
<p>There is also one provided helper method on the <code>InterleavedBuffer&lt;'a&gt;</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view_raw_attribute&lt;'b&gt;(
    &amp;'b self,
    attribute: &amp;PointAttributeMember
) -&gt; RawAttributeView&lt;'b&gt;
    where 'a: 'b { ... }
<span class="boring">}</span></code></pre></pre>
<p>It returns a <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/struct.RawAttributeView.html">more efficient accessor</a> for the values of a specific attribute compared to calling <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html#method.get_attribute"><code>get_attribute</code></a> multiple times.</p>
<p>For buffers that provide mutable access to their memory, there is a mutable variant of <code>InterleavedBuffer&lt;'a&gt;</code>, called <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.InterleavedBufferMut.html"><code>InterleavedBufferMut&lt;'a&gt;</code></a>. It looks similar to <code>InterleavedBuffer&lt;'a&gt;</code>, except that all methods return mutable borrows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait InterleavedBufferMut&lt;'a&gt;: InterleavedBuffer&lt;'a&gt; + BorrowedMutBuffer&lt;'a&gt; {
    // Required methods
    fn get_point_mut&lt;'b&gt;(&amp;'b mut self, index: usize) -&gt; &amp;'b mut [u8]
       where 'a: 'b;
    fn get_point_range_mut&lt;'b&gt;(
        &amp;'b mut self,
        range: Range&lt;usize&gt;
    ) -&gt; &amp;'b mut [u8]
       where 'a: 'b;

    // Provided method
    fn view_raw_attribute_mut&lt;'b&gt;(
        &amp;'b mut self,
        attribute: &amp;PointAttributeMember
    ) -&gt; RawAttributeViewMut&lt;'b&gt;
       where 'a: 'b { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>Notice that it is a supertrait of both <code>InterleavedBuffer&lt;'a&gt;</code> and <code>BorrowedMutBuffer&lt;'a&gt;</code>: It requires both an interleaved memory layout <em>and</em> mutably borrowed buffer memory!</p>
<h3 id="columnar-buffers-and-the-columnarbuffera-trait"><a class="header" href="#columnar-buffers-and-the-columnarbuffera-trait">Columnar buffers and the <code>ColumnarBuffer&lt;'a&gt;</code> trait</a></h3>
<p>For columnar memory layouts, there is the <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.ColumnarBuffer.html"><code>ColumnarBuffer&lt;'a&gt;</code></a> trait. Here are its required methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ColumnarBuffer&lt;'a&gt;: BorrowedBuffer&lt;'a&gt; {
    // Required methods
    fn get_attribute_ref&lt;'b&gt;(
        &amp;'b self,
        attribute: &amp;PointAttributeDefinition,
        index: usize
    ) -&gt; &amp;'b [u8]
       where 'a: 'b;
    fn get_attribute_range_ref&lt;'b&gt;(
        &amp;'b self,
        attribute: &amp;PointAttributeDefinition,
        range: Range&lt;usize&gt;
    ) -&gt; &amp;'b [u8]
       where 'a: 'b;
}
<span class="boring">}</span></code></pre></pre>
<p>Where interleaved buffers provide by-reference access to whole points, columnar buffers allow borrowing the memory of individual attributes and ranges thereof using the two methods <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.ColumnarBuffer.html#tymethod.get_attribute_ref"><code>get_attribute_ref</code></a> and <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.ColumnarBuffer.html#tymethod.get_attribute_range_ref"><code>get_attribute_range_ref</code></a>. There are few surprises here, they work the same way the point-accessors on <code>InterleavedBuffer&lt;'a&gt;</code> do. There is also a raw attribute range accessor identical to <code>InterleavedBuffer&lt;'a&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view_raw_attribute&lt;'b&gt;(
    &amp;'b self,
    attribute: &amp;PointAttributeMember
) -&gt; RawAttributeView&lt;'b&gt;
    where 'a: 'b { ... }
<span class="boring">}</span></code></pre></pre>
<p>For buffers that provide mutable access to their memory, there is also a mutable variant of <code>ColumnarBuffer&lt;'a&gt;</code>, called <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.ColumnarBufferMut.html"><code>ColumnarBufferMut&lt;'a&gt;</code></a>, which looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ColumnarBufferMut&lt;'a&gt;: ColumnarBuffer&lt;'a&gt; + BorrowedMutBuffer&lt;'a&gt; {
    // Required methods
    fn get_attribute_mut&lt;'b&gt;(
        &amp;'b mut self,
        attribute: &amp;PointAttributeDefinition,
        index: usize
    ) -&gt; &amp;'b mut [u8]
       where 'a: 'b;
    fn get_attribute_range_mut&lt;'b&gt;(
        &amp;'b mut self,
        attribute: &amp;PointAttributeDefinition,
        range: Range&lt;usize&gt;
    ) -&gt; &amp;'b mut [u8]
       where 'a: 'b;

    // Provided method
    fn view_raw_attribute_mut&lt;'b&gt;(
        &amp;'b mut self,
        attribute: &amp;PointAttributeMember
    ) -&gt; RawAttributeViewMut&lt;'b&gt;
       where 'a: 'b { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>It is to <code>ColumnarBuffer&lt;'a&gt;</code> as <code>InterleavedBufferMut&lt;'a&gt;</code> is to <code>InterleavedBuffer&lt;'a&gt;</code>: It contains the same set of methods as <code>ColumnarBuffer&lt;'a&gt;</code>, except they all provide mutable access to the attribute data.</p>
<h2 id="the-implications-for-point-and-attribute-views"><a class="header" href="#the-implications-for-point-and-attribute-views">The implications for point and attribute views</a></h2>
<p>Using all these buffer traits, <code>pasture</code> auto-detects the capabilities of the point and attribute views that you obtain by calling <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html#method.view"><code>view</code></a> and <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/trait.BorrowedBuffer.html#method.view_attribute"><code>view_attribute</code></a> (and their mutable variants) on a buffer. The returned view type is a generic type with conditional implementations based on the memory layout and ownership of the underlying buffer. Here is an example showing the <a href="https://docs.rs/pasture-core/0.4.0/pasture_core/containers/struct.PointView.html"><code>PointView</code></a> type. Its basic implementation looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PointView&lt;'a, 'b, B: BorrowedBuffer&lt;'a&gt;, T: PointType&gt;
where
    'a: 'b,
{ /* private fields */ }
<span class="boring">}</span></code></pre></pre>
<p>It wraps around a generic buffer type <code>B</code>, which has to at least implement the basic buffer trait <code>BorrowedBuffer&lt;'a&gt;</code>. Based on this trait, the point view can only provide by-value access to the point data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, 'b, B: BorrowedBuffer&lt;'a&gt;, T: PointType&gt; PointView&lt;'a, 'b, B, T&gt;
where
    'a: 'b {
    pub fn at(&amp;self, index: usize) -&gt; T { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>If we want by-reference access to points, the underlying buffer must have interleaved memory layout:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, 'b, B: InterleavedBuffer&lt;'a&gt;, T: PointType&gt; PointView&lt;'a, 'b, B, T&gt;
where
    'a: 'b {
    pub fn at_ref&lt;'c&gt;(&amp;'c self, index: usize) -&gt; &amp;'c T
    where
        'b: 'c { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>The other accessors are implemented conditionally in a similar way. Not only does this reduce code duplication, it also allows you to explicitly specify which type of point cloud data access you want in your generic code:</p>
<pre><code>fn process_data_by_ref&lt;'a, 'b, B: InterleavedBuffer&lt;'a&gt;&gt;(point_view: PointView&lt;'a, 'b, B, PointType&gt;) {
    // Requires by-reference access to points of type `PointType`! 
}
</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note"></a></p>
</div>
<div>
<p>The <code>at_ref</code> function of <code>PointView</code> has <em>three</em> distinct lifetimes! This is necessary because there can be up to three distinct lifetimes when calling <code>at_ref</code>:</p>
<ol>
<li>The lifetime for which we borrow the individual point (<code>'c</code>)</li>
<li>The lifetime for which the <code>PointView</code> is valid (<code>'b</code>)</li>
<li>The lifetime for which the underlying buffer borrows its memory (<code>'a</code>)</li>
</ol>
</div>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../point_buffers/builtin_types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../point_buffers/buffer_slices.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../point_buffers/builtin_types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../point_buffers/buffer_slices.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
